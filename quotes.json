[
  {
    "quote": "Good software practice requires such discipline(Total Productive Maintenance): focus, presence of mind, and thinking. It is not always just about doing, about pushing the factory equipment to produce at the optimal velocity. \nOne of the major pillars of TPM is the set of so-called 5S principles. \nSeiri, or organization (think “sort” in English). Knowing where things are—using approaches such as suitable naming—is crucial. \nSeiton, or tidiness (think “systematize” in English). There is an old American saying: A place for everything, and everything in its place. A piece of code should be where you expect to find it—and, if not, you should re-factor to get it there. \nSeiso, or cleaning (think “shine” in English): Keep the workplace free of hanging wires, grease, scraps, and waste. What do the authors here say about littering your code with comments and commented-out code lines that capture history or wishes for the future? Get rid of them. \nSeiketsu, or standardization: The group agrees about how to keep the workplace clean. \nShutsuke, or discipline (self-discipline). This means having the discipline to follow the practices and to frequently reflect on one’s work and be willing to change.",
    "note": null
  },
  {
    "quote": "Clean code is not just cost effective; it's a matter of professional survival.",
    "note": null
  },
  {
    "quote": "We are deeply complicit in the planning of the project and share a great deal of the responsibility for any failures; especially if those failures have to do with bad code!",
    "note": "We tend to blame stupid managers and useless marketing types. But we are the ones the managers and marketers look to for promises and commitments. We have choices and should speak up, and of course, write clean code."
  },
  {
    "quote": "The only way to make the deadline-the only way to go fast-is to keep the code as clean as possible at all times.",
    "note": null
  },
  {
    "quote": "A programmer who writes clean code is an artist who can take a blank screen through a series of transformations until it is an elegantly code system.",
    "note": "wow when programing turns into art"
  },
  {
    "quote": "I like my code to be elegant and efficient. The logic should be straightforward to make it hard for bugs to hide, the dependencies minimal to ease maintenance, error handling complete according to an articulated strategy, and performance close to optimal so as not to tempt people to make the code messy with unprincipled optimization. Clean code does one thing well._By: Bjarne Stroutstrup, inventor of C++",
    "note": null
  },
  {
    "quote": "Clean code can be read, and enhanced by a developer other than its original author. It has unit and acceptance tests. It has meaningful names. It has minimal dependencies, which are explicitly defined, and provides a clear and minimal API. Code should be literate since depending on the language, not all necessary information can be expressed clearly in code alone._By: Dave Thomas, founder of OTI",
    "note": null
  },
  {
    "quote": "Reduced duplication, high expressiveness, and early building of simple abstractions. That's what makes clean code for me._By: Ron Jeffries, author of Extreme Programming Installed and Extreme Programming Adventures in C#",
    "note": null
  },
  {
    "quote": "If you want to go fast, if you want to get done quickly, if you want your code to be easy to write, make it easy to read.",
    "note": null
  },
  {
    "quote": "The Boy Scout Rule: “Leave the campground cleaner than you found it. If we all checked-in our code a little cleaner than when we checked it out, the code simply could not rot.",
    "note": null
  },
  {
    "quote": "Use intention-revealing names.",
    "note": null
  },
  {
    "quote": "The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent.",
    "note": null
  },
  {
    "quote": "Programmers must avoid leaving false clues that obscure the meaning of code. We should avoid words whose entrenched meanings vary from our intended meaning.",
    "note": null
  },
  {
    "quote": "Noise words are redundant. Distinguish names in such a way that the reader knows what the differences offer.",
    "note": null
  },
  {
    "quote": "Make your names pronounceable, so that we can make intelligent conversations between programmers.",
    "note": null
  },
  {
    "quote": "The length of a name should correspond to the size of its scope [N5]. If a variable or constant might be seen or used in multiple places in a body of code, it is imperative to give it a search-friendly name. Uncle Bob's personal preference: a single-letter names can ONLY be used as local variables inside short methods",
    "note": null
  },
  {
    "quote": "Professional understands that clarity is king. Professionals use their powers for good and write code that others can understand.",
    "note": null
  },
  {
    "quote": "Classes and objects should have noun or noun phrase names. Methods should have verb or verb phrase names. Accessors, mutators, and predicates should be named for their value and prefixed with get, set, and is according to standards.",
    "note": null
  },
  {
    "quote": "Pick one word for one abstract concept and stick with it. For instance, it's confusing to have fetch, retrieve, and get as equivalent methods of different classes. A consistent lexicon is a great boon to the programmers who must use your code.",
    "note": null
  },
  {
    "quote": "Avoid using the same word for two purposes. Using the same term for two different ideas is essentially a pun.",
    "note": null
  },
  {
    "quote": "The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that.",
    "note": null
  },
  {
    "quote": "The blocks within if statements, else statements, while statements, and so on should be one line long. Probably that line should be a function call. Not only does this keep the enclosing function small, but it also adds documentary value because the function called within the block can have a nicely descriptive name.",
    "note": null
  },
  {
    "quote": "functions should not be large enough to hold nested structures. Therefore, the indent level of a function should not be greater than one or two. This, of course, makes the functions easier to read and understand.",
    "note": null
  },
  {
    "quote": "Functions should do one thing. They should do it well. They should do it ONLY.",
    "note": null
  },
  {
    "quote": "Dividing a function into sections is an obvious symptom of doing more than one thing. Functions that do one thing cannot be reasonably divided into sections.",
    "note": null
  },
  {
    "quote": "In order to make sure our functions are doing 'one thing', we need to make sure that the statements within our function are all at the same level of abstraction.",
    "note": null
  },
  {
    "quote": "We want the code to read like a top-down narrative. We want every function to be followed by those at the next level of abstraction so that we can read the program. To say this differently, we want to be able to read the program as though it were a set of TO paragraphs, each of which is describing the current level of abstraction and referencing subsequent TO paragraphs at the next level down.",
    "note": null
  },
  {
    "quote": "General rule for switch statements is that they can be tolerated if they appear only once, are used to create polymorphic objects, and are hidden behind an inheritance relationship so that the rest of the system can’t see them.",
    "note": null
  },
  {
    "quote": "The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification—and then shouldn’t be used anyway.",
    "note": "pass them as instance variables, instead of passing them around as arguments in functions"
  },
  {
    "quote": "When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own.",
    "note": null
  },
  {
    "quote": "Side effects are lies. Your function promises to do one thing, but it also does other hidden things.",
    "note": null
  },
  {
    "quote": "Don't repeat yourself. Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it.",
    "note": null
  }
]